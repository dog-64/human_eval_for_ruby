 <reasoning>
Мне нужно написать функцию min_sub_array_sum, которая находит минимальную сумму среди всех непустых подмассивов заданного массива. Давайте подумаем, как это сделать эффективно.

Сначала вспомню, что подмассивы — это непрерывные последовательности элементов. Например, для массива [2,3,4], подмассивы будут [2], [3], [4], [2,3], [3,4], [2,3,4]. Нужно найти сумму каждого из них и выбрать минимальную.

Но если массив большой, например, с N элементами, то перебор всех возможных подмассивов будет иметь сложность O(N^2), что неэффективно для больших N. Поэтому нужен более оптимальный подход.

Вспомнил алгоритм Kadane's для нахождения максимальной суммы подмассива. Возможно, его можно модифицировать для поиска минимальной суммы. Да, именно так. Kadane's алгоритм можно адаптировать, меняя знаки и направление сравнений.

Идея такая: поддерживаем текущую минимальную сумму подмассива, заканчивающегося на текущем элементе. Для каждого элемента мы решаем, лучше добавить его к текущему подмассиву или начать новый подмассив с этого элемента. Затем обновляем глобальную минимальную сумму, если текущая меньше.

Например, для массива [-1, -2, -3], текущая сумма на каждом шаге будет -1, -3, -6. Глобальная минимальная будет -6.

Реализация будет примерно такой:

Инициализируем current_min и global_min первым элементом массива. Затем проходим по остальным элементам. Для каждого элемента current_min = минимум между текущим элементом и суммой current_min + текущий элемент. Затем обновляем global_min, если current_min меньше.

Таким образом, алгоритм работает за O(N) времени и O(1) памяти, что подходит для задачи.

Теперь проверю примеры:

Пример 1: [2,3,4,1,2,4]. Минимальный подмассив — [1], сумма 1. Алгоритм должен найти это. Последовательно обновляя current_min и global_min.

Пример 2: [-1,-2,-3]. Все суммы будут отрицательными, и global_min будет -6.

Пример 3: [1]. Результат 1.

Пример 4: [5,-1,2,-3]. Возможно, минимальный подмассив — [-1,2,-3], сумма -2? Или [-1], сумма -1? Или [2,-3], сумма -1? Или [-1,2,-3] сумма -2. Но по примеру ожидается -3. Возможно, я где-то ошибся. Посмотрю пример: вход [5, -1, 2, -3]. Возможно, минимальный подмассив — [-1, 2, -3], сумма -1 +2 -3 = -2. Но в примере ожидается -3. Тогда, возможно, я неправильно понял пример. Проверю:

Вход [5, -1, 2, -3]. Возможные подмассивы:

5 → 5

5,-1 →4

5,-1,2 →6

5,-1,2,-3 →3

-1 →-1

-1,2 →1

-1,2,-3 →-2

2 →2

2,-3 →-1

-3 →-3

Минимальная сумма здесь -3. То есть подмассив [-3]. Значит, алгоритм должен найти это. Но как?

При обработке элемента -3:

current_min = min(-3, current_min_prev + (-3)). Предположим, предыдущий current_min был -2 (из подмассива [-1,2]). Тогда current_min = min(-3, -2 + (-3) = -5) → -5. Но тогда global_min обновится до -5? Но в примере ожидается -3. Значит, где-то ошибка в логике.

Ой, нет. Возможно, я неправильно применил алгоритм. Давайте разберемся.

Для примера [5, -1, 2, -3]:

Инициализируем current_min = 5, global_min =5.

Второй элемент -1:

current_min = min(-1, 5 + (-1) =4) → -1. global_min теперь -1.

Третий элемент 2:

current_min = min(2, -1 +2=1) →1. global_min остается -1.

Четвертый элемент -3:

current_min = min(-3, 1 + (-3) =-2) →-3. Теперь global_min обновляется до -3. В итоге возвращается -3, что соответствует примеру. Значит, алгоритм работает правильно.

Значит, мой подход верен.

Теперь напишу код.

Функция будет принимать массив nums. Если массив пустой, но по условию это невозможно.

Инициализируем current_min и global_min первым элементом.

Затем проходим по остальным элементам:

for num in nums[1..-1]
  current_min = [num, current_min + num].min
  global_min = [global_min, current_min].min
end

Возвращаем global_min.

Теперь преобразую это в Ruby-код.

def min_sub_array_sum(nums)
  current_min = nums[0]
  global_min = nums[0]

  nums[1..-1].each do |num|
    current_min = [num, current_min + num].min
    global_min = [global_min, current_min].min
  end

  global_min
end

Проверю примеры:

Для [5,-1,2,-3]:

current_min начинается с 5, global_min 5.

Второй элемент -1:

current_min = [-1, 5-1=4].min →-1. global_min →-1.

Третий элемент 2:

current_min = [2, -1+2=1].min →1. global_min остается -1.

Четвертый элемент -3:

current_min = [-3, 1-3=-2].min →-3. global_min становится -3.

Вернет -3. Все правильно.

Другой пример: [-1,-2,-3]. Каждый шаг:

current_min и global_min будут -1, -3, -6. Вернет -6.

Еще пример [1] → вернет 1.

Таким образом, код должен работать правильно.
</reasoning>

def min_sub_array_sum(nums)
  current_min = nums[0]
  global_min = nums[0]

  nums[1..-1].each do |num|
    current_min = [num, current_min + num].min
    global_min = [global_min, current_min].min
  end

  global_min
end

 