 <reasoning>
Мне нужно написать функцию histogram для Ruby. Давайте разберемся с требованиями.

Функция принимает строку и возвращает хеш с подсчетом частоты каждого символа. Но только строчные латинские буквы, остальное игнорируем. Если несколько букв имеют максимальную частоту, то все они должны быть в хеше с этими значениями.

Первым делом, нужно обработать входной текст. Надо пройтись по каждому символу строки и отфильтровать только те, которые являются строчными буквами латинского алфавита. Как это сделать? Можно использовать метод each_char, а затем проверять каждый символ с помощью регулярного выражения. Например, символ.match?(/[a-z]/) — если да, то учитываем его.

После фильтрации, нужно подсчитать частоту каждого символа. Для этого можно использовать хеш, где ключ — символ, а значение — количество вхождений. Можно инициализировать пустой хеш, а затем для каждого символа увеличивать счетчик.

Но потом возникает вопрос: как найти максимальную частоту и собрать все символы, которые имеют эту частоту. Например, если максимальная частота 2, и есть два символа с этим значением, то в итоговом хеше должны быть оба.

Итак, шаги:

1. Обработать входную строку, оставив только строчные буквы.
2. Подсчитать частоту каждого символа.
3. Найти максимальную частоту среди всех символов.
4. Собрать все символы, у которых частота равна максимальной.
5. Создать новый хеш только с этими символами и их частотами.

Но как это реализовать на Ruby?

Начнем с фильтрации символов. Можно использовать текст.chars.map { |c| c if c.match?(/[a-z]/) }.compact. Это даст массив только букв.

Затем подсчитываем частоты. Можно использовать Hash.new(0) и пройтись по массиву символов, увеличивая счетчики.

Потом находим максимальное значение среди значений хеша. Если хеш пустой, возвращаем пустой хеш.

Затем создаем новый хеш, включающий только те ключи, значения которых равны максимальному.

Теперь объединим все это в функцию.

Пример:

Для 'a b b a' после фильтрации получаем ['a', 'b', 'b', 'a']. Частоты: a:2, b:2. Максимум 2. В итоговом хеше оба символа.

Еще пример: 'b b b b a' → частоты b:4, a:1. Максимум 4 → только b.

Теперь код:

Сначала обработка текста:

def histogram(text)
  # фильтруем символы
  letters = text.chars.select { |c| c.match?(/[a-z]/) }
  # подсчитываем частоты
  freq = Hash.new(0)
  letters.each { |c| freq[c] += 1 }
  # если нет букв, возвращаем пустой хеш
  return {} if freq.empty?
  # находим максимальную частоту
  max_freq = freq.values.max
  # фильтруем хеш, оставляя только max_freq
  freq.select { |k, v| v == max_freq }
end

Проверим примеры:

Для 'a b c' → letters = ['a','b','c'], freq {a:1, b:1, c:1}, max 1 → все три.

Для 'a b b a' → freq {a:2, b:2}, max 2 → оба.

Для 'a b c a b' → a:2, b:2 → оба.

Для 'b b b b a' → b:4, a:1 → только b.

Пустая строка → возвращаем {}.

Еще пример с несколькими максимумами: 'a b c d a b c d e' → частоты a:2, b:2, c:2, d:2, e:1. Максимум 2 → все четыре.

Кажется, все работает. Но нужно убедиться, что функция правильно обрабатывает пустой вход. Если text пуст, то letters будет пустым, freq тоже пуст, возвращаем {}.

Также проверить случай, когда все символы не буквы. Например, '123 !@#' → letters пуст, возвращаем {}.

Вроде все учтено. Теперь напишем код, следуя правилам: только Ruby, идиоматично, snake_case для методов и переменных.
</reasoning>

def histogram(text)
  letters = text.chars.select { |c| c.match?(/[a-z]/) }
  freq = Hash.new(0)
  letters.each { |c| freq[c] += 1 }
  return {} if freq.empty?
  max_freq = freq.values.max
  freq.select { |k, v| v == max_freq }
end

 