 <reasoning>
Мне нужно написать функцию choose_num(x, y), которая находит наибольшее чётное число в диапазоне от x до y включительно. Если такого числа нет, вернуть -1.

Сначала подумаю о том, как определить диапазон. Возможно, что x больше y, поэтому нужно сначала определить правильный порядок. Например, если x=13, y=15, то диапазон от 13 до 15. Но если x=15, y=10, то диапазон будет от 10 до 15. Значит, сначала нужно определить начало и конец диапазона. Можно использовать [x, y].reverse, чтобы получить правильный порядок. Или просто начать цикл от минимального до максимального.

Далее, нужно найти самое большое чётное число в этом диапазоне. Чётные числа делятся на 2 без остатка. Значит, можно идти с конца диапазона и проверять каждое число на чётность. Как только найдём первое чётное число, это и будет ответ.

Например, для диапазона 12-15: проверяем 15 (нечётное), 14 (чётное) — возвращаем 14. Для 13-15: 15 (нечётное), 14 (чётное) — тоже 14.

Если диапазон пустой (например, x=13, y=12), то сразу возвращаем -1.

Также нужно учесть случай, когда все числа в диапазоне нечётные. Например, x=1, y=3: 3, 2, 1. 2 чётное, значит возвращаем 2. Но если x=1, y=1 — тогда нет чётных, возвращаем -1.

Итак, алгоритм:

1. Определить начало и конец диапазона: start = [x, y].min, end = [x, y].max.
2. Если start > end, вернуть -1 (хотя по условию входные параметры положительные, но если x > y, то диапазон пуст).
3. Идти от end к start, проверяя каждое число на чётность.
4. Первое найденное чётное число — это максимальное, возвращаем его.
5. Если ни одно не найдено, вернуть -1.

Как реализовать проверку чисел от end до start? Можно использовать цикл while или each.

Например:

start = [x, y].min
end_range = [x, y].max

if start > end_range
  return -1
end

current = end_range
while current >= start
  if current.even?
    return current
  end
  current -= 1
end

return -1

Это должно работать. Но можно оптимизировать. Например, если end_range чётное, то сразу возвращаем его. Если нет, то вычитаем 1 и проверяем, чётное ли получилось. Если end_range нечётное, то следующее число (end_range -1) может быть чётным. Если это так, то это максимальное чётное. Если же end_range -1 меньше start, то ищем дальше.

Например:

if end_range.even?
  return end_range
else
  candidate = end_range - 1
  if candidate >= start
    return candidate
  else
    # тогда идём вниз до start, ищем чётное
  end
end

Но возможно, это усложнит код. Лучше пройтись по циклу, но с оптимизацией. Например, начать с end_range и шагать на -1, пока не найти чётное.

Также можно использовать range в Ruby. Например, (start..end_range).reverse_each do |n| ... end. Но reverse_each перебирает все элементы в обратном порядке. Это может быть неэффективно для больших диапазонов, но для задачи, вероятно, это не критично.

Но цикл while будет более эффективен, так как может завершиться на первом же шаге.

Теперь реализуем это в Ruby.

Функция:

def choose_num(x, y)
  start = [x, y].min
  end_range = [x, y].max

  return -1 if start > end_range

  current = end_range
  while current >= start
    if current.even?
      return current
    end
    current -= 1
  end

  -1
end

Проверим примеры:

Пример 1: choose_num(12,15) → 14. Проверяем 15 (нечётное), 14 (чётное) → возвращаем 14. Верно.

Пример 2: choose_num(13,15) → 14. 15 нечётное, 14 чётное. Верно.

Пример 3: choose_num(13,12) → start=12, end=13. Проверяем 13 (нечётное), 12 (чётное). Вернёт 12? Но по условию, если x > y, то диапазон [x,y] не существует. Но в коде start = [13,12].min → 12, end_range = 13. Тогда диапазон 12..13. Проверяем 13 (нечётное), 12 (чётное). Возвращаем 12. Но в примере 3 ожидается -1. Ой, ошибка!

В примере 3: x=13, y=12. По условию, функция должна вернуть -1. Но в текущем коде start=12, end_range=13. Диапазон 12-13. В нём есть 12, которое чётное. Поэтому функция вернёт 12, но по условию задачи, если x > y, то диапазон от x до y не существует, и нужно вернуть -1?

Ой, нет. В условии сказано: "функция должна корректно обрабатывать случаи, когда x больше y". То есть, диапазон считается от min до max. То есть, если x=13, y=12, то диапазон [12,13], и в нём есть 12, которое чётное. Поэтому пример 3 в описании задачи, возможно, ошибка? Посмотрим на примеры:

В примере 3: choose_num(13, 12) возвращает -1. Но согласно коду, вернёт 12. Значит, мой код неверен.

Что здесь не так? По условию, входные параметры x и y — положительные целые числа. Но диапазон [x, y] включает все числа от min до max. То есть, если x=13, y=12, то диапазон [12,13]. В этом диапазоне есть 12, которое чётное. Поэтому функция должна вернуть 12, но в примере 3 ожидается -1. Значит, я неправильно понял условие.

Посмотрю на описание задачи:

**Особые случаи и ограничения:**

* Функция должна корректно обрабатывать случаи, когда x больше y.

То есть, диапазон считается от x до y, но если x > y, то диапазон пуст? Или всё равно считается от min до max?

В описании задачи в примере 3: choose_num(13, 12) возвращает -1. Но если диапазон считается от min до max, то 12 и 13, и 12 чётное. Тогда пример 3 должен вернуть 12, но по условию возвращает -1. Значит, я неправильно понял условие.

Возможно, в условии под диапазоном от x до y подразумевается именно [x, y], и если x > y, то диапазон пуст, и нужно вернуть -1. То есть, если x > y, то нет чисел между ними, и функция возвращает -1.

Тогда в примере 3, x=13, y=12, диапазон пуст, возвращаем -1. Но тогда как быть с примером 6: choose_num(2,2) возвращает 2. То есть, когда x=y и чётное.

Значит, мой код неверен. Нужно изменить логику: если x > y, то возвращаем -1, иначе ищем в диапазоне от x до y.

То есть, сначала проверяем, если x > y, то возвращаем -1. Иначе ищем в диапазоне от x до y.

Но тогда как быть с примером 3: x=13, y=12. x > y → возвращаем -1. Это соответствует примеру.

Тогда код должен быть изменён:

def choose_num(x, y)
  return -1 if x > y

  start = x
  end_range = y

  current = end_range
  while current >= start
    if current.even?
      return current
    end
    current -= 1
  end

  -1
end

Теперь пример 3: x=13, y=12 → x>y → возвращаем -1. Это правильно.

Но тогда как быть с примером 6: x=2, y=2 → x <= y → ищем. 2 чётное → возвращаем 2. Верно.

Пример 5: x=1, y=1 → x <= y. Проверяем 1 → нечётное. Цикл завершается, возвращаем -1. Верно.

Пример 7: choose_num(100, 101) → x=100 <= y=101. Проверяем 101 (нечётное), 100 (чётное) → возвращаем 100. Верно.

Теперь проверим пример 3: choose_num(13,12) → возвращаем -1. Теперь правильно.

Но тогда как быть с примером, где x=12, y=13 → диапазон 12-13. 13 нечётное, 12 чётное → возвращаем 12. Верно.

Теперь код должен работать правильно.

Теперь проверим другие примеры:

Пример 1: choose_num(12,15) → x=12 <= y=15. Проверяем 15 (нечётное), 14 (чётное) → вернуть 14. Верно.

Пример 2: choose_num(13,15) → x=13 <= y=15. Проверяем 15 (нечётное), 14 (чётное) → вернуть 14. Верно.

Пример 4: choose_num(1,3) → x=1 <= y=3. Проверяем 3 (нечётное), 2 (чётное) → вернуть 2. Верно.

Пример 6: choose_num(2,2) → вернуть 2. Верно.

Пример 5: choose_num(1,1) → вернуть -1. Верно.

Пример 7: choose_num(100,101) → вернуть 100. Верно.

Теперь код должен работать правильно.

Теперь нужно написать этот код, следуя всем правилам.

Проверим, что все условия соблюдены:

- Используется snake_case для метода: choose_num — правильно.
- Возвращаем -1, если нет чётных чисел.
- Обрабатывает x > y, возвращая -1.
- Использует Ruby-специфичные конструкции, например, while, current -=1.

Теперь напишем код.
</reasoning>

def choose_num(x, y)
  return -1 if x > y

  current = y
  while current >= x
    return current if current.even?
    current -= 1
  end

  -1
end

 