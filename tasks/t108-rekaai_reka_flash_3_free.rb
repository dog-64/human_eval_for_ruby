 <reasoning>
Мне нужно написать функцию count_nums, которая считает количество элементов в массиве, у которых сумма цифр больше нуля. Давайте подумаем, как это сделать.

Сначала, для каждого числа в массиве, нужно вычислить сумму его цифр. Но есть нюанс: если число отрицательное, то первая цифра считается отрицательной, а остальные — положительными. Например, -123: сумма будет -1 + 2 + 3 = 4.

Итак, шаги:

1. Перебрать каждый элемент массива.
2. Для каждого элемента вычислить сумму его цифр с учетом знака первой цифры.
3. Проверить, больше ли сумма нуля.
4. Подсчитать количество таких элементов.

Как обработать отрицательные числа? Например, число -123. Нужно взять его абсолютное значение, разбить на цифры, первую цифру умножить на -1, остальные оставить как есть, затем сложить.

Но как разбить число на цифры? Можно преобразовать число в строку, убрать знак (или оставить для первой цифры), затем пройтись по каждому символу, преобразовать в цифры.

Например, для числа -123:

Строка "-123". Убираем знак, получаем "123". Первая цифра '1' становится -1, остальные 2 и 3. Сумма: -1 + 2 +3 =4.

Для числа 11: сумма 1+1=2>0.

Для числа -10: строка "-10". Убираем знак, "10". Первая цифра -1, остальные 0. Сумма -1+0 =-1 <0. Не подходит.

Теперь, как реализовать сумму цифр с учетом знака первой цифры.

Шаги для одного числа:

- Если число отрицательное, то первая цифра (после знака) умножается на -1.
- Остальные цифры суммируются как есть.

Например:

Число: -123
Строка: "-123"
digits = ["-", "1", "2", "3"]
Но, возможно, проще взять абсолютное значение числа, преобразовать в строку, затем разбить на символы, пропустив первый символ (если число отрицательное), и обработать первый символ как отрицательный.

Или:

def sum_digits(n)
  return 0 if n == 0
  str = n.abs.to_s
  digits = str.chars.map(&:to_i)
  if n < 0
    digits.first *= -1
  end
  digits.sum
end

Проверим:

n = -123 → str = "123", digits = [1,2,3]. Поскольку n <0, первый элемент умножаем на -1 → [-1,2,3]. Сумма 4. Верно.

n = -10 → str "10", digits [1,0]. Сумма -1 +0 =-1.

n = 11 → [1,1] → сумма 2.

n = 0 → sum 0.

Теперь, функция sum_digits должна возвращать сумму цифр с учетом знака первой цифры для отрицательных чисел.

Теперь, основная функция count_nums:

def count_nums(arr)
  arr.count { |num| sum_digits(num) > 0 }
end

Но нужно реализовать sum_digits как вложенный метод или отдельную функцию.

Но в Ruby можно определить внутри метода count_nums вложенный метод sum_digits.

Или определить его отдельно.

Но по правилам, нужно использовать только Ruby, и код должен быть идиоматичным.

Теперь, проверим примеры:

Пример 1: count_nums([-1, 11, -11]) → должно вернуть 1.

Для -1: sum_digits(-1) → str "1", digits [1]. n <0 → первый элемент -1. Сумма -1 → не больше 0.

11: sum 2 → больше 0.

-11: str "11", digits [1,1]. n <0 → первый элемент -1. Сумма -1 +1 =0 → не больше 0. Итого 1 элемент (11). Верно.

Пример 2: [-10, 0, 10] → суммы:

-10 → sum -1 +0 =-1 → нет.

0 → sum 0 → нет.

10 → sum 1+0=1 → да. Итого 1.

Пример 3: [-20,-30,-40] → каждое число:

-20 → sum -2 +0 =-2 → нет.

-30 → sum -3 +0 =-3 → нет.

-40 → sum -4 +0 =-4 → нет. Итого 0.

Теперь, реализация sum_digits.

Но что делать с нулем? sum_digits(0) → 0. Если число 0, то сумма цифр 0, которая не больше нуля. Так что такие элементы не будут учитываться.

Теперь, код:

def count_nums(arr)
  def sum_digits(n)
    return 0 if n == 0
    str = n.abs.to_s
    digits = str.chars.map(&:to_i)
    digits.first *= -1 if n < 0
    digits.sum
  end

  arr.count { |num| sum_digits(num) > 0 }
end

Проверим:

Для числа -10:

sum_digits(-10) → str "10", digits [1,0]. n <0 → первый элемент -1. Сумма -1 +0 =-1 → не больше 0.

Для числа 10 → sum 1+0=1 → больше 0.

Теперь, проверим код на примерах.

Пример 1: count_nums([]) → 0. Верно.

Пример 2: count_nums([-1, 11, -11]) → 1. Верно.

Пример 3: count_nums([1,1,2]) → 3. Все суммы 1,1,2 → все больше 0.

Пример 4: count_nums([-10,0,10]) → 1. Верно.

Пример 5: count_nums([-20,-30,-40]) → 0. Верно.

Кажется, все работает.

Теперь, нужно убедиться, что код соответствует всем правилам:

1. Только Ruby код, без маркеров и т.д. — да.

2. Не Python синтаксис — все правильно.

3. Нет примеров использования — код только функция.

4. Нет повторяющегося кода — нет.

5. Идиоматичный Ruby: использование count, блоков, методов.

6. Нет Python-библиотек — все встроенные.

7. snake_case для методов: sum_digits, count_nums — да.

8. CamelCase для классов и модулей — нет классов здесь.

9. ? для булевых методов — нет таких.

10. ! для модифицирующих методов — нет.

Все правила соблюдены.
</reasoning>

def count_nums(arr)
  def sum_digits(n)
    return 0 if n == 0
    str = n.abs.to_s
    digits = str.chars.map(&:to_i)
    digits.first *= -1 if n < 0
    digits.sum
  end

  arr.count { |num| sum_digits(num) > 0 }
end

 