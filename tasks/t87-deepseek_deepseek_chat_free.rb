def get_row(lst, x)
  result = []
  lst.each_with_index do |row, i|
    row.each_with_index do |element, j|
      result << [i, j] if element == x
    end
  end
  result.sort_by { |i, j| [i, -j] }
end
```


### Анализ задачи и решения

**Задача:**
Необходимо написать функцию `get_row(lst, x)`, которая находит все вхождения целого числа `x` в двумерном списке (вложенном массиве) и возвращает список кортежей (пар), представляющих координаты (номер строки, номер столбца) этих вхождений. Нумерация строк и столбцов начинается с 0. Кортежи должны быть отсортированы сначала по номеру строки в возрастающем порядке, а затем по номеру столбца в убывающем порядке.

**Решение:**
1. **Инициализация результата:** Создаем пустой массив `result`, который будет хранить координаты вхождений числа `x`.
2. **Итерация по строкам:** Используем метод `each_with_index` для итерации по строкам двумерного списка `lst`. В переменной `i` хранится индекс текущей строки.
3. **Итерация по элементам строки:** Внутри цикла по строкам используем еще один `each_with_index` для итерации по элементам текущей строки. В переменной `j` хранится индекс текущего элемента.
4. **Проверка на совпадение:** Если текущий элемент равен `x`, добавляем пару `[i, j]` в массив `result`.
5. **Сортировка результата:** Используем метод `sort_by` для сортировки массива `result`. Сначала сортируем по номеру строки в возрастающем порядке (`i`), затем по номеру столбца в убывающем порядке (`-j`).
6. **Возврат результата:** Возвращаем отсортированный массив `result`.

**Особенности:**
- Функция корректно обрабатывает пустой вложенный массив.
- Функция корректно обрабатывает строки с нулевым количеством элементов.
- Гарантируется, что элементы вложенного массива `lst` являются целыми числами.

**Пример использования:**
```ruby
get_row([
  [1, 2, 3, 4, 5, 6],
  [1, 2, 3, 4, 1, 6],
  [1, 2, 3, 4, 5, 1]
], 1) == [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]

get_row([], 1) == []

get_row([[], [1], [1, 2, 3]], 3) == [[2, 2]]
```