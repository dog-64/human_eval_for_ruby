 <reasoning>
Мне нужно написать функцию words_string, которая разбивает строку на слова, игнорируя запятые и пробелы как разделители. Давайте подумаем, как это сделать.

Сначала, нужно обработать входную строку. Возможно, сначала заменить все запятые на пробелы, чтобы потом можно было разделить по любым пробелам. Например, строка "Hi, my name" после замены запятых на пробелы станет "Hi  my name". Тогда разделение по пробелам даст ["Hi", "my", "name"].

Но как быть с последовательностями пробелов или запятых? Например, "one,,two   three" — после замены запятых на пробелы получится "one  two   three". Разделение по пробелам с удалением лишних проб даст правильные слова.

Так что шаги могут быть такими:
1. Заменить все запятые в строке на пробелы.
2. Разбить строку на части по любым пробельным символам (один или несколько).
3. Убрать пустые строки из результата, если они есть.

Например, для строки "One, two, three, four, five, six" замена запятых на пробелы даст "One  two  three  four  five  six". Разделение по пробелам даст массив, где элементы — слова, а между ними пустые строки, если были множественные пробелы. Но split с пробелом автоматически убирает лишние пробелы и возвращает массив без пустых элементов. Проверю: "a   b".split(' ') вернет ["a", "b"], а "a,,b".split(' ') после замены запятых на пробелы станет "a  b".split(' ') → ["a", "b"].

Тогда алгоритм такой:
- Создать новую строку, заменив все запятые на пробелы.
- Разделить эту строку на слова, используя split с пробелом как разделитель. По умолчанию split без аргумента разделяет по любым пробельным символам и убирает пустые элементы. Но если использовать split(' '), то для строки с несколькими пробелами между словами получим массив с пустыми элементами? Нет, wait: "a  b".split(' ') → ["a", "", "b"], а "a  b".split → ["a", "b"]. Значит, лучше использовать split без аргумента, чтобы автоматически обработать любые пробелы и запятые, замененные на пробелы.

Таким образом, шаги:
s.gsub(/,/, ' ').split

Но нужно проверить, что если исходная строка пустая, то вернется пустой массив. Например, words_string("") → [].

Также нужно учесть случаи, когда после замены запятых на пробелы получается пустая строка или только пробелы. Например, если входная строка ",, , ", то после замены запятых на пробелы получится "  ,  ", split вернет пустой массив.

Таким образом, функция может выглядеть так:

def words_string(s)
  s.gsub(/,/, ' ').split
end

Проверим примеры:

Пример 1: "Hi, my name is John" → замена запятых на пробелы → "Hi  my name is John". split → ["Hi", "my", "name", "is", "John"] — правильно.

Пример 2: "One, two, three, four, five, six" → замена запятых → "One  two  three  four  five  six". split → правильный массив.

Пример 3: "Hello world" → split без изменений → ["Hello", "world"].

Пример 4: "" → split возвращает [].

Особые случаи: строка с только запятыми, например ",,," → замена на пробелы → "   ", split → [].

Если слово содержит запятую внутри, например "hello,world", то замена запятой на пробел даст "hello world", split → ["hello", "world"], но согласно условию, слова не должны содержать запятых. Но в условии сказано, что предполагается, что слова не содержат запятых внутри себя. То есть, если входная строка содержит запятую внутри слова, например "test,ing", то после замены запятой на пробел получится "test ing", что разделит слово на два. Но согласно условию, такого не должно быть. То есть, функция должна считать, что запятые только как разделители, а не часть слова. Но если входная строка содержит запятую внутри слова, например "test,ing", то функция разобьет его на "test" и "ing", что неверно. Но по условию задачи, такие случаи не предусмотрены. То есть, предполагается, что запятые только как разделители, и слова не содержат запятых. Поэтому функция будет работать правильно, так как разделителями считаются только запятые и пробелы, а внутри слов запятые не встречаются.

Таким образом, решение должно быть таким: заменить все запятые на пробелы, затем разделить строку на слова, удалив лишние пробелы.

Теперь напишу код:

def words_string(s)
  s.gsub(/,/, ' ').split
end

Проверим все примеры:

Для "Hi, my name is John" → замена запятых → "Hi  my name is John". split → ["Hi", "my", "name", "is", "John"] — верно.

Для "One, two, three, four, five, six" → после замены → "One  two  three  four  five  six". split → правильный массив.

Пустая строка → [].

Строка с запятыми и пробелами: ",, , " → замена на пробелы → "  ,  " → split → [].

Строка с словом, содержащим запятую: "test,ing" → замена → "test ing" → split → ["test", "ing"], но согласно условию, такого не должно быть, но функция будет обрабатывать это как два слова. Но по условию задачи, такие случаи не предусмотрены, поэтому функция работает правильно.

Таким образом, код удовлетворяет требованиям.
</reasoning>

def words_string(s)
  s.gsub(/,/, ' ').split
end

 