 <reasoning>
Мне нужно написать функцию unique_digits, которая принимает список чисел и возвращает отсортированный список тех чисел, которые не содержат ни одной чётной цифры. Давайте подумаю, как это сделать.

Сначала, для каждого числа в списке нужно проверить все его цифры. Если хотя бы одна цифра чётная, то число исключаем. Иначе оставляем его.

Как проверить, все ли цифры нечётные? Можно преобразовать число в строку, разбить на символы, преобразовать каждый обратно в цифру и проверить, все ли они нечётные.

Например, для числа 15: цифры 1 и 5 — обе нечётные. Значит, число подходит.

Теперь шаги:

1. Пройтись по каждому числу в списке.
2. Для каждого числа проверить, все ли его цифры нечётные.
3. Собрать все подходящие числа в новый массив.
4. Отсортировать этот массив по возрастанию.
5. Вернуть отсортированный массив.

Как реализовать проверку цифр? Можно создать метод, который проверяет, все ли цифры числа нечётные. Например:

def all_odd?(number)
  number.to_s.chars.all? { |c| c.to_i.odd? }
end

Тогда для числа 15: all_odd?(15) вернёт true. Для 1422: false.

Теперь функция unique_digits:

def unique_digits(numbers)
  numbers.select { |n| all_odd?(n) }.sort
end

Но нужно убедиться, что numbers — это массив целых положительных чисел. Но по условию функция принимает только такие, так что, возможно, проверку не нужно добавлять. Но вдруг входные данные могут быть некорректными? Нет, по условию функция должна обрабатывать только положительные целые числа, так что проверку можно опустить.

Теперь проверим примеры:

Пример 1: [15, 33, 1422, 1]
После фильтрации останутся 15, 33, 1. Сортируем: [1, 15, 33] — совпадает с примером.

Пример 2: [152, 323, 1422, 10]
152 содержит 5 (нечётная), 2 (чётная) — исключаем. 323: все цифры нечётные? 3, 2, 3 — 2 чётная, значит исключаем. 1422 — все чётные. 10 — 0 чётная. Все исключаются, результат пустой.

Пример 3: все числа из нечётных цифр, включая 111 и 333. Отсортированный массив как есть.

Пример 4: пустой массив — возвращаем пустой.

Теперь нужно реализовать метод all_odd? как часть функции или внутри. В Ruby можно определить вложенный метод, но лучше определить его внутри unique_digits.

Итак, полный код:

def unique_digits(numbers)
  def all_odd?(number)
    number.to_s.chars.all? { |c| c.to_i.odd? }
  end

  numbers.select { |n| all_odd?(n) }.sort
end

Проверяем, нет ли повторений кода. В условии сказано не повторять уже предоставленный код, но здесь all_odd? определяется внутри unique_digits, что допустимо.

Также проверяем, что используется идиоматический Ruby. Методы с ? и ! используются правильно. Здесь all_odd? — подходит.

Теперь тесты. Например, для числа 0: но по условию входные числа положительные, так что 0 не входит. Число 1: все цифры нечётные.

Всё должно работать.
</reasoning>

def unique_digits(numbers)
  def all_odd?(number)
    number.to_s.chars.all? { |c| c.to_i.odd? }
  end

  numbers.select { |n| all_odd?(n) }.sort
end

 